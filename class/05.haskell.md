# Haskell intro

[_Задължително_ четиво](http://learnyouahaskell.com)

Какво се случи:
0. Мини-мотивация за `Haskell`
1. Как да се сдобием с `Haskell` (и други полезни линкове)
2. Какво може `ghci`
3. *Някои* примитиви
4. Синтаксис на функции
5. (малко) Списъци

## 1. Как да се сдобием с `Haskell` (и други полезни линкове)
За Linux - `your distros package manager`

За Windows - [Цък](https://www.haskell.org/downloads)

### "Какво IDE да ползвам?"
Лично ползвам `your favourite text editor` + terminal, така че
не мога да дам мнение, но може да се разровите [тук](https://wiki.haskell.org/IDEs).

[Leksah](http://www.leksah.org) изглежда като да работи.

(това може и да е готина възможност да разцъкате vim например)

### [Hoogle](https://www.haskell.org/hoogle/)
Препоръчвам, когато се чудите "Има ли тази функция?" или пък
"Как се казваше тази функция?" да го ползвате. Както споменах
можете да търсите по име на функция, но също така 
и по сигнатура на функция.

## 2. Какво може `ghci`
Като за начало как да пуснем файл с `ghci`?
Можете или директно 
```
ghci asdf.hs
```
да отворите файла, или пък да пуснете `ghci` и в последствие да го заредите с `:load (:l)`
```
ghci
Prelude> :l asdf.hs
```
За да не трябва да отваряме и затваряме постоянно или пък
да пишем постоянно името на файла имаме `:reload (:r)`, което
действа по self-explanatory начин. Излизането от `ghci`
става чрез `:quit (:q)`.

Идвайки към най-якото нещо – можем да питаме `ghci` да ни каже
типа на някое име използвайки `:type (:t)`. Например:
```Haskell
Prelude> :t 'a'
'a' :: Char
Prelude> :t True
True :: Bool
Prelude> :t 5
5 :: Num t => t
```
#### *Важно*
Виждаме синтаксиса `X :: Y` – означава че X е от тип Y.
Последното е малко по-странно и предполагам че много скоро
ще бъде споменато на упражнение, но като цяло може да си
мислите за него като за всички типове 't', които "могат да
бъдат числа". Можем да питаме `ghci` и за типовете на функции,
което е по-полезната част, особено когато се опитваме да
навържем няколко подред. Не обръщайте много внимание за сега.

За функции виждаме типове със стрелкички между тях:
```Haskell
Prelude> :t id -- идентитет
id :: a -> a
Prelude> :t const -- взима два аргумента и винаги връща първия
const :: a -> b -> a
```
Какво означава това? Ами просто казано функцията връща нещо
от типа, който е след последната стрелка, а всичките останали
типове са "аргументите" ѝ. Хубаво е да направите mental note,
че всъщност всяка функция взима един аргумент, но това ще
бъде обсъдено в по-голяма дълбочина по-късно.
#### "Какъв е този тип 'a'?" (или 'b' или 't')
Когато е зададена някаква малка буквичка за тип това означава,
че може да е какъвто и да е тип. Или както се изрази един ваш
колега – "както темплейтите в C++" (но доста по-просто). 
Какво означава това за нас? В този случай можем да приложим
`id` върху _какъвто_ и тип да искаме.

Можем също така да питаме и за по-подробното `:info (:i)`,
което дава информация за къде е дефинирана някоя функция и
други подобни подробности.

## 3. *Някои* примитиви
Както видяхме по-горе имаме `Char`-ове и `Bool`-ове. Има също така
и всички нормални неща, които бихме очаквали – `Int`, `Double`,
г/д каквото се сетите. Има и такова нещо `Integer`, което
е същото като `Int`, но може да приема неограничени
стойности (доколкото ви стига RAM-та), докато `Int` е
класическото n-битово число (където n е зависимо от процесора
ви). Очевидно на него му е по-лесно да ползва `Int`-ове.

Имаме също така и прости аритметични функции каквито бихме очаквали:
#### NOTE: Функциите, които са оператори (като +), трябва да оградим със скоби, 
####       за да можем да реферираме към тях (или пък да ги извикваме префиксно)
```Haskell
Prelude> :t (+) -- събиране
(+) :: Num a => a -> a -> a
Prelude> :t (-) -- изваждане
(-) :: Num a => a -> a -> a
Prelude> :t (*) -- умножение
(*) :: Num a => a -> a -> a
Prelude> :t (/) -- дробно деление
(/) :: Fractional a => a -> a -> a
Prelude> :t quot -- взимане на цяла част (quotient)
quot :: Integral a => a -> a -> a
Prelude> :t rem -- взимане на остатък (remainder)
rem :: Integral a => a -> a -> a
Prelude> :t succ -- "наследник" (successor), демек +1
succ :: Enum a => a -> a
```

Можем да сравняваме неща:
```Haskell
Prelude> :t (<) 
(<) :: Ord a => a -> a -> Bool
Prelude> :t (<=)
(<=) :: Ord a => a -> a -> Bool
Prelude> :t (==)
(==) :: Eq a => a -> a -> Bool
Prelude> :t (/=) -- "различно от"
(/=) :: Eq a => a -> a -> Bool
```

## 4. Синтаксис на функции
Като за начало най-простото нещо, което можем да направим
е да декларираме нещо на интерпретатора с `let` и после
да поискаме стойността му.
```Haskell
Prelude> let a = 5
Prelude> a
5
```
Малко повече, можем по същия начин да декларираме и функции и
да ги извикваме по подобен начин.
```Haskell
Prelude> let identity x = x
Prelude> :t identity
identity :: t -> t
Prelude> identity 42
42
```
(Забележете че извикването на функция не изисква да оградим
аргументите ѝ със скоби.)
Какво казваме? Ами функцията identity взима един аргумент (x)
и връща самия него. Същото нещо с функциите и декларацията
можем да правим и в .hs документ, но там не ползваме `let` –
то е специфично за интерпретатора.
```Haskell
sumthree x y z = x + y + z
```
Както виждате можем да изпуснем типа (или сигнатурата) на
функцията, защото хората, които са правили GHC са били
достатъчно умни да се сетят, че да пишем за всичко винаги
тип (например вместо просто `5.0` да пишем `5.0 :: Double`) е досадно.  
За това са направили нещо наречено type inference – компилаторът
може донякъде да познае типовете на нещата.

Това е много удобно, но също така е и добре познат факт,
че за всяка функция, която напишете без сигнатура, 
Бате Бобо пуска по една сълза (не искате той да плаче,
нали?). 

Jokes aside, писането на сигнатура МНОГО помага
да осъзнаете какво *всъщност* искате да направите и освен
това ви спира от това да пишете програми с грешни
типове (до някаква степен). За това:
```Haskell
sumthree :: Int -> Int -> Int
sumthree x y z = x + y + z
```
### if-then-else
Очевидно за да пишем каквото и да е смислено трябва да 
можем да разклоняваме програмата си:
```Haskell
factorial :: Int -> Int
factorial x = if x == 0 then 1 else x * factorial (x - 1)
```
Не смятам за нужно да обяснявам какво прави `if-then-else` конструкцията.
"Но нали каза, че не трябва да ограждаме аргументите на
функциите със скоби?"
И тук бихме настъпили една мотика. В живота някои неща са 
по-важни от други. Така и в `Haskell` – някои неща имат
по-висок приоритет. И кое е най-важното? Функциите. Очевидно.
Прилагането на функция има най-висок приоритет сред операциите
в `Haskell` и като резултат, ако напишем само 
```Haskell
factorial x - 1
```
вместо желаното от нас извикване на факториел с x - 1, ще 
получим извикване на факториел с x, от който резултат е
извадено 1.
### Guards
Нека напишем нещо друго – например втората най-любима 
студентска функция – `fib n` - връща n-тото число на от
редицата на Фибоначи.
```Haskell
fib :: Int -> Int
fib n = if n == 0 then 1
        else if n == 1 then 1
             else fib (n - 2) + fib (n - 1)
```
Както виждате не е много готино да образуваме диагонали
от `if`-ове и за това имаме друг синтаксис, който г/д
съответства на `case` в други езици. Наричат се `guards`:
```Haskell
fib' :: Int -> Int
fib' n 
    | n == 0    = 1
    | n == 1    = 1
    | otherwise = fib' (n - 2) + fib' (n - 1)
```
Ah, much better. Подравняването не е задължително, но изглежда
по-добре. Не е голям rocket science – всеки
ред с "pipe"-че на него (символа '|') дефинира
един случай от вида 
```Haskell
    | CONDITION = RESULT
```
Просто проверяваме (подред на записване отгоре-надолу)
условията и ако някое от тях е истина то тогава 
функцията взима стойността отдясно на равното. 
`otherwise` хваща всичко – сеедноче да напишем `True` там 
вместо него.

Тук е хубав момент да спомена, че 
1. В `Haskell` имат значение местата
2. `Haskell` не харесва табулациите (and the same should go for you)
За това ако всичко изглежда правилно, но не се компилира,
проверете да не би да сте объркали индентацията по някакъв начин.

#### But wait, it gets better! (for real)
### Pattern matching
Можем да напишем нещо още по-красиво
```Haskell
fib'' :: Int -> Int
fib'' 0 = 1
fib'' 1 = 1
fib'' n = fib (n - 2) + fib (n - 1)
```
К'во е т'ва? Еми това е т.нар. `pattern matching` –
ако името не ви подсказва ни позволява да зададем някакви
"шаблони", с които да се сравнят нашите аргументи. Те също
се проверяват в реда, в който са дефинирани и както и при
guard-овете връщаме това, което е отдясно на съответния "шаблон".
Когато някой от "шаблоните" match-не параметрите, с които 
сме извикали функция, променливите в шаблона (тук `n`) се свързват
с параметрите. Например:
```Haskell
fib'' 0 -- това извикване match-ва с първата дефиниция, и директно връща 1
fib'' 42 -- това извикване не match-ва нито с fib'' 0 нито с fib'' 1
         -- но пък ще match-не на долното условие, което хваща произволна променлива
         -- n и като резултат променливата n ще стане равна на 42, изпълнявайки дясната
         -- страна на pattern match-а след това, тоест
fib'' 42 = fib'' (42 - 2) + fib'' (42 - 1)
```
Всъщност много по-лесен начин за мислене (imo) е да си мислим
че дефинираме поточково (поелементно, както искате) функцията
`fib''` (както бихме в математиката). Казваме, че 

- за 0 функцията ни е равна на 1
- за 1 е равна на 1 
- за всички останали числа тя е равна на блабла

И така покрихме всички естествени числа (за които и е
дефинирана `fib` по принцип)

Забележете, че в третия случай няма опасност да викнем
fib от отрицателно число, защото сме се подсигурили с горните
два pattern-а , че в този случай `n > 1` (иначе щеше да 
попаднем в някой от горните случаи).

#### По какво можем да `pattern match`-ваме? 
С други думи – какви "шаблони" можем да задаваме?

Отговорът е всякакви литерали и специален вид функции наречени конструктори.
(и освен това произволно влагане на конструктори един в друг, стига на дъното
да има литерал или променлива).

За конструктори ще кажем доста по-късно някоя дума или друга, но за сега ще
pattern match-ваме освен по литерали и по списъци. 
```Haskell
<interactive>:1:1: error: Variable not in scope: списъци
```
Wait a second...


## 5. (малко) Списъци

Добре се познавате с това понятие от курса до сега, така че нека направо разгледаме синтаксиса му
в `Haskell`:
```Haskell
Prelude> :t []              -- празен списък
[] :: [t] j
Prelude> :t ['a','b','c']   -- списък от Char-ове
['a','b','c'] :: [Char]
Prelude> :t "abc"           -- списък от Char-ове.. wait what?
"abc" :: [Char]
Prelude> :t 'a':['b','c']   -- слепяне на елемент към списък, (aka cons от Racket)
'a':['b','c'] :: [Char]
Prelude> :t 'a':'b':'c':[]  -- истината за списъците :O
'a':'b':'c':[] :: [Char]
```
Имаме празен списък `[]` – self-explanatory. Защо той е от тип `[t]` ще говорим много скоро.

Списъци с елементи като `['a','b','c']` се създават чрез изброяване на елементите през запетаи.
Не можем да имаме списък `[5, a]` защото какъв би бил типа на това? В примера по-горе ясно виждаме,
че типът на `['a','b','c']` е списък от `Char`-ове, но `[5, a]` няма такъв лесно-описуем тип.
С други думи списъците в `Haskell` са хомогенни.

Както виждате отгоре дори да напишем `"abc"` – нещо което интуитивно смятаме за `String`, `ghci` ни
казва че това е списък от `Char`-ове. И нито ние грешим, нито той – оказва се че типът `String` в
`Haskell` е просто "alias" за списък от `Char`-ове. С други думи като да напишем `#define` в `C/C++`.

В `Haskell` слепянето на елемент към списък става по същия начин както в `Racket`, но тук функцията е
кръстена `(:)`. Имаме и също така класическите `head` и `tail` съответстващи съответно на `car` и `cdr`:
```Haskell
Prelude> :t (:)             -- слепяне
(:) :: a -> [a] -> [a]
Prelude> :t head            -- първи елемент
head :: [a] -> a
Prelude> :t tail            -- остатък от списък
tail :: [a] -> [a]
```

Какво е това ужасно нещо което виждаме на последния ред? Ами знаейки какво прави `(:)` не е много
трудно да съобразим – че това е просто списъкът `['a','b','c']`. Как? Ами това е `'a'` слепено към
списъка `'b':'c':[]`. А пък това е `'b'` слепено към списъка `'c':[]`. Ами това е просто `'c'` слепено
към списъка `[]`. А ние вече знаем как да слепим `'c'` към празния списък.
За щастие, както и в `Racket` така и тук никога няма да си мислим по този начин за списък,
но е хубаво да знаете, че както в `Racket` така и тук това е всъщност как изглежда наистина
този списък за `Haskell`. Нашият запис (`['a','b','c']`) е просто синтактична захар. 

Знаейки това за вида на списъците не е трудно да си представим че, да видиш ти, можеш да pattern match-ваш
по тях:
```Haskell
length' :: [a] -> Int       -- дължина на списък 
length' [] = 0
length' (x:xs) = 1 + length' xs
```
Какво казваме? `[]` има дължина 0. После какъвто и да е списък, който може да се представи като някакъв
елемент `x` (`head`) слепен към някакъв остатък `xs` (`tail`) има дължина 1 + дължината на остатъка.
Cool. Със същия успех може да заменим `x` с `_`, защото както забелязваме ние никъде не ползваме `x`,
а пък `_` означава точно това – "каквото и да е, не ми пука, го свързвай с някакво име, няма да го ползвам".
Още един пример, но в който всъщност изпозлваме `x`-а:
```Haskell
elem' :: Int -> [Int] -> Bool           -- елемент ли е първият аргумент на втория
elem' _ [] = False                      -- какъвто и да е първият аргумент, той не е елемент на празния списък
elem' y (x:xs) = if x == y then True    -- y е елемент на списъка, който се разбива на x и xs (тоест поне един елемент)
                 else elem' y xs        -- или ако x е равно на y или ако y е елемент на xs
```
